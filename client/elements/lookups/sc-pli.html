<link rel="import" href="/bower_components/polymer/polymer.html">

<dom-module id="sc-pali-lookup">
  <template>

  </template>

  <script>
      class SCPaliLookup extends Polymer.Element {
          static get is() {
              return 'sc-pali-lookup';
          }

          static get properties() {
          }

          lookupWordHandler(event) {
              if (!sc.userPrefs.getPref("paliLookup")) return;
              if (!'paliDictionary' in window) return;

              if ($(this).children().is("span.meaning")) return;

              var word = $(this).text().toLowerCase().trim();
              word = word.replace(/­/g, '').replace(RegExp(syllSpacer, 'g'), '');//optional hyphen, syllable-breaker

              if (reverseMap[word]) {
                  meaning += word + " : ";
                  word = reverseMap[word];
              }
              word = word.replace(/ṃg/g, 'ṅg').replace(/ṃk/g, 'ṅk').replace(/ṃ/g, 'ṃ').replace(/Ṃ/g, 'ṃ');
              var meaning = lookupWord(word);
              if (meaning) {
                  var textBox = $('<span class="meaning">' + meaning + '</span>');
                  $(this).append(textBox);
                  sc.formatter.rePosition(textBox);
              }
          }

          lookupWord(word) {

              var allMatches = [];

              var isTi = false;
              if (word.match(/[’”]ti$/)) {
                  isTi = true;
                  word = word.replace(/[’”]ti$/, "");
              }
              word = word.replace(/[’”]/g, "");
              var original = word;
              var unword = null; //The un-negated version.

              //First we try to match the word as-is
              var m = matchComplete(word, { "ti": isTi });
              if (!m || m.length == 0) {
                  if (word.search(/^an|^a(.)\1/) != -1) unword = word.substring(2, word.length)
                  else if (word.search(/^a/) != -1) unword = word.substring(1, word.length);
                  if (unword) {
                      m = matchComplete(unword, { "ti": isTi });
                      if (m && m.length > 0) {
                          allMatches.push({ "base": "an", "meaning": "non/not" });
                      }
                  }
              }
              if (m && m.length > 0) {
                  allMatches = allMatches.concat(m);
              }


              if (allMatches.length == 0) {
                  //Now we attempt to break up the compound.
                  //First is special case since 'an' is possibility.
                  var m = matchPartial(word);
                  if (unword) {
                      var unm = matchPartial(unword);
                      if ((unm && !m) || (unm && m && unm.base.length > m.base.length)) {
                          m = unm;
                          allMatches.push({ "base": "an", "meaning": "non/not" });
                      }
                  }
                  var foundComplete = false;
                  while (m && !foundComplete) {
                      allMatches = allMatches.concat(m);
                      var leftover = m.leftover;
                      var sandhi = m.base[m.base.length - 1];
                      var firstchar = leftover[0];
                      leftover = leftover.substring(1, leftover.length);
                      var starts = [firstchar, "", sandhi + firstchar];
                      var vowels = ['a', 'ā', 'i', 'ī', 'u', 'ū', 'o', 'e'];
                      //As a rule sandhi doesn't shortern vowels
                      if (sandhi == 'a' || sandhi == 'i' || sandhi == 'u') vowels = ['a', 'i', 'u'];
                      for (i in vowels) starts.push(vowels[i] + firstchar);
                      var foundComplete = false;
                      for (i in starts) {
                          m = matchComplete(starts[i] + leftover, { "ti": isTi });
                          if (m && m.length > 0) {
                              allMatches = allMatches.concat(m);
                              foundComplete = true;
                              break;
                          }
                          m = matchPartial(starts[i] + leftover);
                          if (m) break;
                      }
                      if (!m) {
                          var base = firstchar + leftover;
                          if (base != 'ṃ') {
                              allMatches.push({ "base": base, "meaning": "?" });
                          }
                          break;
                      }
                  }
                  //In the long run it would be nice to implement 'two ended candle' match.
              }

              var out = "";
              if (allMatches.length == 0) {
                  allMatches.push({ "base": original, "meaning": "?" });
              }
              if (isTi) allMatches.push({ "base": "iti", "meaning": "endquote" });
              for (var i in allMatches) {
                  var href = "http://suttacentral.net/define/" + allMatches[i].base;

                  out += '<a href="' + href + '" target="_blank">' + allMatches[i].base + '</a>: ' + allMatches[i].meaning;
                  if (i != allMatches.length - 1) {
                      out += " + ";
                  }
              }
              return out;
          }

          matchComplete(word, args) {
              var matches = [];
              for (var pi = 0; pi < 2; pi++) // 'pi (list)
                  for (var vy = 0; vy < 2; vy++) // vy / by (burmese)
                      for (var ti = 0; ti < 2; ti++) // 'ti (end quote)
                      {
                          //On the first pass change nothing.
                          var wordp = word;
                          //On the second pass we change the last vowel if 'ti', otherwise skip.
                          if (ti && args.ti == true) {

                              wordp = wordp.replace(/ī$/, "i").replace(/ā$/, "i").replace(/ū$/, "i").replace(/n$/, "").replace(/n$/, "ṃ");
                          }
                          if (pi) {
                              if (wordp.search(/pi$/) == -1) continue;
                              wordp = wordp.replace(/pi$/, "");
                          }
                          if (vy) {
                              if (wordp.match(/vy/)) wordp = wordp.replace(/vy/g, 'by')
                              else if (wordp.match(/by/)) wordp = wordp.replace(/by/g, 'vy')
                              else continue;
                          }

                          var m = exactMatch(wordp) || fuzzyMatch(wordp);
                          if (m) {
                              matches.push(m);
                              if (pi) matches.push({ "base": "pi", "meaning": "too" });
                              return matches;
                          }
                      }

              return null;
          }

          matchPartial(word, maxlength) {
              //Matching partials is somewhat simpler, since all ending cases are clipped off.
              for (var vy = 0; vy < 2; vy++) {
                  var wordp = word;
                  if (vy) {
                      if (wordp.match(/vy/)) wordp = wordp.replace(/vy/g, 'by')
                      else if (wordp.match(/by/)) wordp = wordp.replace(/by/g, 'vy')
                      else continue;
                  }

                  if (!maxlength) maxlength = 4;
                  for (var i = 0; i < word.length; i++) {
                      var part = word.substring(0, word.length - i);
                      if (part.length < maxlength) break;
                      var target = sc.piLookup.data[part]
                      if (typeof(target) == 'object') {
                          var meaning = target[1];
                          if (meaning === undefined) {
                              meaning = target[0];
                          }

                          return {
                              "base": part,
                              "meaning": meaning,
                              "leftover": word.substring(word.length - i, word.length)
                          }
                      }
                  }
              }
          }

          //Every match should return an object containing:
          // "base": The base text being matched
          // "meaning": The meaning of the matched text.
          // "leftovers": Anything which wasn't matched by the function, should be empty string
          //  or null if meaningless (such as a grammatical insertion ie. 'ti')
          exactMatch(word) {
              var target = sc.piLookup.data[word];
              if (typeof(target) == 'object') {
                  if (target[1] === undefined) {
                      var meaning = target[0];
                  } else {
                      var meaning = target[1] + ' (' + target[0] + ')';
                  }
                  return { "base": word, "meaning": meaning };
              }
              return null;
          }

          fuzzyMatch(word) {
              var end = sc.piLookup.endings;
              for (var i = 0; i < end.length; i++) {
                  if (word.length > end[i][2] && word.substring(word.length - end[i][0].length, word.length) === end[i][0]) {
                      var orig = word.substring(0, word.length - end[i][0].length + end[i][1]) + end[i][3];
                      var target = sc.piLookup.data[orig];
                      if (typeof(target) == 'object') {
                          if (target[1] === undefined) {
                              var meaning = target[0];
                          } else {
                              var meaning = target[1] + ' (' + target[0] + ')';
                          }
                          return { "base": orig, "meaning": meaning };
                      }
                  }
              }
              return null;
          }
      }

      customElements.define(SCPaliLookup.is, SCPaliLookup);
  </script>
</dom-module>

