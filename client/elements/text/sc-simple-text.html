<link rel="import" href="/bower_components/polymer/polymer.html">

<link rel="import" href="/elements/text/sc-text-options.html">
<link rel="import" href="/styles/sc-text-styles.html">
<link rel="import" href="/styles/sc-text-heading-styles.html">
<link rel="import" href="/styles/sc-text-paragraph-num-styles.html">
<link rel="import" href="/elements/lookups/sc-pli.html">

<dom-module id="sc-simple-text">

  <template>
    <style include="sc-text-styles sc-text-heading-styles sc-text-paragraph-num-styles">
      :host{
        --paper-tooltip: {
          @apply --sc-skolar-font-size-s;
          opacity: 1;
          max-width: 200px;
          background-color: var(--paper-grey-700);
        }
      }

      .lookup-link {
          color: white !important;
          font-weight: bold;
      }

      .text-center {
        text-align: center;
      }

      .margin-top-xl {
        margin-top: 10vh;
      }

      h1 {  /* it is here becouse of the difference on how h1 calculates margin for bare text and text in spans */
        -webkit-margin-before: 12px;
      }

    </style>

    <div id="simple_text_content" class="html-text-content" inner-h-t-m-l="[[assembledText]]"
         hidden$="[[isTextViewHidden]]"></div>

    <template is="dom-if" if="[[!sutta.text]]">
      <div class="text-center margin-top-xl">
        <h2>Error</h2>
        <h3>Could not find the sutta text.</h3>
      </div>
    </template>

    <template is="dom-if" if="[[isPaliLookupEnabled]]">
        <sc-pali-lookup id="pali_lookup"></sc-pali-lookup>
    </template>

  </template>

  <script>
      class SCSimpleText extends ReduxMixin(Polymer.Element) {
          static get is() {
              return 'sc-simple-text';
          }

          static get properties() {
              return {
                  // in simple texts, both root texts and translations are returned by the API in the translation object.
                  sutta: {
                      type: Object,
                      observer: '_updateView'
                  },
                  // If true, shows the paragraph numbers on the right of the text.
                  showParagraphs: {
                      type: Boolean,
                      statePath: 'textOptions.paragraphsEnabled',
                      observer: '_computeParagraphs'
                  },
                  paliScript: {
                      type: String,
                      statePath: 'textOptions.script',
                      observer: 'changeScript'
                  },
                  paragraphs: {
                      type: Array,
                      statePath: 'textOptions.paragraphDescriptions'
                  },
                  suttaTitlte: {
                      type: String
                  },
                  author: {
                      type: String
                  },
                  lang: {
                      type: String
                  },
                  isLoading: {
                      type: Boolean,
                      observer: '_loadingChanged'
                  },
                  error: {
                      type: Object
                  },
                  isTextViewHidden: {
                      type: Boolean,
                      value: false
                  },
                  assembledText: {
                      type: String
                  },
                  isPaliLookupEnabled: {
                    type: Boolean,
                    statePath: 'textOptions.paliLookupActivated',
                    observer: '_paliLookupStateChanged'
                  },
                  tooltipCounter: {
                      type: Number,
                      value: 0
                  },
                  isLookupAllowed: {
                      type: Boolean,
                      value: false
                  },
                  spansGenerated: {
                      type: Boolean,
                      value: false
                }
              }
          }

          static get actions() {
              return {
                  changeToolbarTitle(title) {
                      return {
                          type: 'CHANGE_TOOLBAR_TITLE',
                          title: title
                      };
                  },
                  changeSuttaMetaText(metaText) {
                      return {
                          type: 'CHANGE_SUTTA_META_TEXT',
                          metaText: metaText
                      }
                  }
              }
          }

          _updateView() {
              this._setAttributes();
              this._updateToolbar();
              this._computeParagraphs();
              // Scroll to the section after the hash sign in the url:
              this._scrollToSection(window.location.hash.substr(1), false, 500);
          }

          _setAttributes() {
              if (!this.sutta) {
                  return;
              }
              this.author = this.sutta.author;
              this.lang = this.sutta.lang;
              this.suttaTitle = this.sutta.title;
              this.assembledText = this.sutta.text;
          }

          _updateToolbar() {
              if (!this.sutta || !this.sutta.text) {
                  return;
              }
              this.dispatch('changeSuttaMetaText', this._computeMeta());
              const title = this.author ? `${this.suttaTitle} â€“ ${this.author}` : `${this.suttaTitle}`;
              this.dispatch('changeToolbarTitle', title);
          }

          // returns the meta-data from the loaded sutta text
          _computeMeta() {
              const matches = this.sutta.text.match(/<aside id="metaarea">((.|\n)*)<\/aside>/);
              let metaText;
              try {
                  if (matches && matches.length > 0) {
                      metaText = matches[1];
                  } else {
                      metaText = '';
                  }
              } catch (e) {
                  console.error(e);
              }
              return metaText;
          }

          // After the paragraph list has been loaded, adds relevant data to the placeholders in the sutta text file.
          _computeParagraphs() {
              if (this.paragraphs && this.showParagraphs) {
                  this._addParagraphScrollListeners();
              }
              this._setParagraphsVisible(this.showParagraphs);
          }

          _addParagraphScrollListeners() {
              this.paragraphs.forEach((paragraph) => {
                  const refs = this.$.simple_text_content.querySelectorAll(`.${paragraph.uid}`);
                  Array.from(refs).forEach((item) => {
                      this._addParagraphData(item, paragraph);
                  });
              });
              this.assembledText = this.$.simple_text_content.innerHTML;
          }

          _addParagraphData(item, data) {
              item.innerHTML = item.id.replace(data.uid, '');
              item.title = data.description;
              item.href = `#${item.id}`;
              item.addEventListener('click', () => {
                  this._scrollToSection(item.id, true, 0);
              });
          }

          // adds a class to the main container to either show or hide the textual info paragraphs
          _setParagraphsVisible(visible) {
              const textElement = this.$.simple_text_content;
              if (textElement) {
                  visible ? textElement.classList.add('infomode') : textElement.classList.remove('infomode');
              }
          }

          _loadingChanged() {
              this.isTextViewHidden = !!(this.isLoading);
          }

          // Scrolls to the chosen section
          _scrollToSection(sectionId, isSmooth, delay) {
              if (!sectionId) return;
              try {
                  const section = this.shadowRoot.getElementById(sectionId);
                  setTimeout(() => {
                      section.scrollIntoView({
                          behavior: isSmooth ? 'smooth' : 'instant',
                          block: 'start',
                          inline: 'nearest'
                      });
                  }, delay);
              } catch (e) {
                  console.error(e);
              }
          }

          changeScript(paliScript) {
              if (!this.sutta || this.sutta.lang !== 'pli') {
                  return;
              }
              const tooltips = this.shadowRoot.querySelectorAll('paper-tooltip');
              this._resetScript();
              switch (paliScript) {
                  case 'latin':
                      this.$.simple_text_content.classList.add('latin-script');
                      break;
                  case 'sinhala':
                      this._setScript('sinhala', tooltips);
                      break;
                  case 'devanagari':
                      this._setScript('devanagari', tooltips);
                      break;
                  case 'thai':
                      this._setScript('thai', tooltips);
                      break;
                  case 'myanmar':
                      this._setScript('myanmar', tooltips);
                      break;
              }
              this._computeParagraphs();
          }

          _resetScript() {
              this.$.simple_text_content.classList
                  .remove('latin-script', 'sinhala-script', 'devanagari-script', 'thai-script', 'myanmar-script');
              this.$.simple_text_content.innerHTML = this.sutta.text;
          }

          _setScript(scriptName, tooltips) {
              this.$.simple_text_content.classList.add(`${scriptName}-script`);
              const t = new Transliterator();
              const scriptFunctionName = `to${this._capitalize(scriptName)}`;
              const textElement = this.shadowRoot.querySelector('#text').querySelector('article');
              this.setSimpleTextContentScript(textElement, t, scriptFunctionName);
              Array.from(tooltips).forEach(item => item.innerHTML = t[scriptFunctionName](item.innerHTML));
              this.assembledText = this.$.simple_text_content.innerHTML;
          }

          setSimpleTextContentScript(elem, transliterator, scriptFunctionName) {
              const childNodes = elem.childNodes;
              if (childNodes && childNodes.length > 0) {
                  childNodes.forEach((item) => {
                      this.setSimpleTextContentScript(item, transliterator, scriptFunctionName);
                      if (item.textContent && item.childNodes.length === 0) {
                          item.textContent = transliterator[scriptFunctionName](item.textContent);
                      }
                  });
              }
          }

          _capitalize(text) {
              return text.charAt(0).toUpperCase() + text.slice(1);
          }

        // Lookup word start
        _wordsIntoSpans(selector){
            if(!this.isPaliLookupEnabled){
                return;
            }
            let segments = this.shadowRoot.querySelectorAll(selector);
            let self = this;
            function process_async(items, process) {
                const temp = () => {
                    const segment = items.shift(); 
                    process(segment, self);
                    self._addLookupTooltips(segment, self);
                    if(items.length > 0) {
                        setTimeout(temp, 0);
                    } else {
                        self.spansGenerated = true;
                    }
                }
                items = Array.from(items);
                setTimeout(temp, 0);
            }
            this.isLookupAllowed = false;
            setTimeout(() => {
                this.isLookupAllowed = true;
            }, 2000) // Allow lookup after 2 seconds.
            process_async(segments, this._segmentIntoSpans);
            }

        _segmentIntoSpans(segment, self){
            const text = segment.innerHTML;
            let div = document.createElement('div');
            div.innerHTML = text;
            self._recurseDomChildren(div, true);
            const str = div.innerHTML.replace(/spfrnt/g, `<span class="word">`).replace(/spback/g, "</span>");
            segment.innerHTML = str;
        }
        _recurseDomChildren(start, output){
            let nodes;
            if(start.childNodes){
                nodes = start.childNodes;
                this._loopNodeChildren(nodes, output);
            }
        }
        _loopNodeChildren(nodes, output){
            let node;
            for(let i=0;i<nodes.length;i++){
                node = nodes[i];
                this._addSpanToNode(node);
                if(node.childNodes){
                    this._recurseDomChildren(node, output);
                }
            }
        }
        _addSpanToNode(node){
            if(node.nodeType != 3) return;
            let tt = node.data;
            let strArr = tt.split(" ");
            let str = "";
            for( let i = 0 ; i < strArr.length; i++) if (strArr[i]){
                str += 'spfrnt' + strArr[i] + 'spback ';
            }
            node.data = str;
        }
    
        _addTooltip(v, tooltip, paliLookup, states, e) {
            let timeToWait = e.sourceCapabilities.firesTouchEvents ? 10 : 100;
            let explenation = paliLookup.lookupWord(v.innerText);
            tooltip.innerHTML = explenation;
            v.parentNode.insertBefore(tooltip, v.nextSibling);
            setTimeout(() => {
                if(states.isWordHovered && !states.isTooltipShowed){
                    v.id = `lookup_target${this.tooltipCounter}`;
                    tooltip.for = `lookup_target${this.tooltipCounter}`;
                    this.tooltipCounter++;
                    tooltip.show();
                    states.isTooltipShowed = true;
                }
            }, timeToWait);
        }

        _removeTooltip(v, tooltip, states, e) {
            let timeToWait = e.sourceCapabilities.firesTouchEvents ? 10 : 100;
            setTimeout(() => {
                if(!states.isWordHovered && !states.isTooltipHovered){
                    v.style.color = '';
                    v.removeAttribute("id");
                    tooltip.hide();
                    states.isTooltipShowed = false;
                }
            }, timeToWait);
        }

        _addLookupTooltips(textContainer, self) {
            self = self || this;
            if(!self.isPaliLookupEnabled){
                return;
            }
            
            let paliLookup = self.shadowRoot.querySelector('#pali_lookup');
            textContainer.querySelectorAll('.word').forEach((v) => {
                let tooltip = document.createElement('paper-tooltip');
                tooltip.animationDelay = 0;
                tooltip.manualMode = true;
                tooltip.fitToVisibleBounds = true;
                tooltip.offset = 0;
                let states = {isWordHovered: false, 
                            isTooltipHovered: false,
                            isTooltipShowed: false};
                v.addEventListener('mouseover', (e) => {
                    if(this.isPaliLookupEnabled && this.isLookupAllowed){
                        v.style.color = '#43A047'; // It can not be in class because of some strange bug in some cases.
                        states.isWordHovered = true;
                        self._addTooltip(v, tooltip, paliLookup, states, e);
                    }
                });
                v.addEventListener('mouseout', (e) => {
                    states.isWordHovered = false;
                    setTimeout(() => {
                    if(!states.isTooltipHovered)
                    v.style.color = '';
                    }, 0);
                    self._removeTooltip(v, tooltip, states, e);
                });
                tooltip.addEventListener('mouseover', (e) => {
                    states.isTooltipHovered = true;
                });
                tooltip.addEventListener('mouseout', (e) => {
                    states.isTooltipHovered = false;
                    self._removeTooltip(v, tooltip, states, e);
                });
            })
        }

        _paliLookupStateChanged(){
            if(this.hidden){
                return;
            }
            if(this.isPaliLookupEnabled){
            if(!this.spansGenerated){
                if(this.lang === 'pli' || this.lang === 'lzh') {
                    this._wordsIntoSpans('.sutta');
                } 
            }
            }
        }
        // Lookup word end

      }

      customElements.define(SCSimpleText.is, SCSimpleText);
  </script>
</dom-module>
