<link rel="import" href="/bower_components/polymer/polymer.html">

<link rel="import" href="/elements/text/sc-text-options.html">
<link rel="import" href="/styles/sc-text-styles.html">
<link rel="import" href="/styles/sc-text-heading-styles.html">
<link rel="import" href="/styles/sc-text-paragraph-num-styles.html">

<!--
The relevant suttaplex card is shown at the top, hidden behind a dropdown (`text/sc-text-options.html`).
Paragraph numbers can be displayed or hidden as requested via the settings-menu in the toolbar.
Title, full Author name and Meta data are sent via events to the page-selector for use in the toolbar.
-->
-->
<dom-module id="sc-simple-text" attributes="suttatitle suttameta">
  <template>
    <style include="sc-text-styles sc-text-heading-styles sc-text-paragraph-num-styles">
      .text-center {
        text-align: center;
      }

      .margin-top-xl {
        margin-top: 10vh;
      }

    </style>

    <div id="simple_text_content" class="html-text-content" inner-h-t-m-l="[[sutta.text]]"
         hidden$="[[isTextViewHidden]]"></div>

    <template is="dom-if" if="[[!sutta.text]]">
      <div class="text-center margin-top-xl">
        <h2>Error</h2>
        <h3>Could not find the sutta text.</h3>
      </div>
    </template>

  </template>

  <script>
      class SCSimpleText extends ReduxMixin(Polymer.Element) {
          static get is() {
              return 'sc-simple-text';
          }

          static get properties() {
              return {
                  // in simple texts, both root texts and translations are returned by the API in the translation object.
                  sutta: {
                      type: Object,
                      observer: '_updateView'
                  },
                  // If true, shows the paragraph numbers on the right of the text.
                  showParagraphs: {
                      type: Boolean,
                      statePath: 'textOptions.paragraphsEnabled',
                      observer: '_computeParagraphs'
                  },
                  paragraphs: {
                      type: Array,
                      statePath: 'textOptions.paragraphDescriptions'
                  },
                  title: {
                      type: String
                  },
                  author: {
                      type: String
                  },
                  lang: {
                      type: String
                  },
                  isLoading: {
                      type: Boolean,
                      observer: '_loadingChanged'
                  },
                  error: {
                      type: Object
                  },
                  isTextViewHidden: {
                      type: Boolean,
                      value: false
                  },
                  isSegmented: {
                      type: Boolean,
                      observer: '_isSegmentedChanged'
                  },
                  assembledText: {
                      type: String
                  }
              }
          }

          static get actions() {
              return {
                  changeToolbarTitle(title) {
                      return {
                          type: 'CHANGE_TOOLBAR_TITLE',
                          title: title
                      };
                  },
                  changeSuttaMetaText(metaText) {
                      return {
                          type: 'CHANGE_SUTTA_META_TEXT',
                          metaText: metaText
                      }
                  }
              }
          }

          ready() {
              super.ready();
              document.addEventListener('visibilitychange', () => { this._handleVisibilityChange() });
          }

          _updateView() {
              this._setAttributes();
              this._updateToolbar();
              this._computeParagraphs();
          }

          connectedCallback() {
              super.connectedCallback();
              console.log(this.$.simple_text_content.innerHTML);
          }

          // Scrolls to the section indicated after the hash sign in the URL:
          _scrollToChosenSection() {
              const sectionId = window.location.hash.substr(1);
              const section = this.$.simple_text_content.querySelector(`#${sectionId}`);
              if (section) {
                  section.scrollIntoView();
              }
          }

          _setAttributes() {
              if (!this.sutta) {
                  return;
              }
              this.author = this.sutta.author;
              this.lang = this.sutta.lang;
              this.title = this.sutta.title;
              this.assembledText = this.$.simple_text_content.innerHTML;
          }

          _updateToolbar() {
              if (!this.sutta || !this.sutta.text || this.isSegmented || this.isSegmented === undefined) {
                  return;
              }
              this.dispatch('changeSuttaMetaText', this._computeMeta());
              const title = this.author ? `${this.title} â€“ ${this.author}` : `${this.title}`;
              this.dispatch('changeToolbarTitle', title);
          }

          // returns the meta-data from the loaded sutta text
          _computeMeta() {
              const matches = this.sutta.text.match(/<aside id="metaarea">((.|\n)*)<\/aside>/);
              let metaText;
              try {
                  if (matches && matches.length > 0) {
                      metaText = matches[1];
                  } else {
                      metaText = '';
                  }
              } catch (e) {
                  console.error(e);
              }
              return metaText;
          }

          // After the paragraph list has been loaded, adds relevant data to the placeholders in the sutta text file.
          _computeParagraphs() {
              if (this.paragraphs && this.showParagraphs) {
                  this.paragraphs.forEach((paragraph) => {
                      const refs = this.shadowRoot.querySelectorAll('.' + paragraph.uid);
                      Array.from(refs).forEach((item) => {
                          item.innerHTML = item.id.replace(paragraph.uid, '');
                          item.title = paragraph.description;
                          item.href = `#${item.id}`;
                      });
                      this.assembledText = this.$.simple_text_content.innerHTML;
                  });
              }
              if (this.showParagraphs) {
                  this._addParagraphs(this.$.simple_text_content);
              } else {
                  this._removeParagraphs(this.$.simple_text_content);
              }
          }

          // adds a class to the main container to either show...
          _addParagraphs(textElement) {
              if (textElement) {
                  textElement.classList.add('infomode');
              }
          }

          // ... or hide paragraph numbers.
          _removeParagraphs(textElement) {
              if (textElement) {
                  textElement.classList.remove('infomode');
              }
          }

          _loadingChanged() {
              this.isTextViewHidden = !!(this.isLoading || this.isSegmented);
          }

          _isSegmentedChanged() {
              this.isTextViewHidden = !!(this.isSegmented);
              this._updateToolbar();
          }

          // Insert the sutta text into the main element again to force reloading styles:
          // This is a hacky solution required because of how inner-h-t-m-l is evaluated in Shady DOM.
          _handleVisibilityChange() {
              if (document.hidden || this.isSegmented) {
                  return;
              }
              // Hide the text and display the loading spinner:
              this.isTextViewHidden = true;
              setTimeout(() => {
                  this.shadowRoot.querySelector('#simple_text_content').innerHTML = this.assembledText;
                  this.isTextViewHidden = false;
              }, 200);
          }

      }

      customElements.define(SCSimpleText.is, SCSimpleText);
  </script>
</dom-module>
